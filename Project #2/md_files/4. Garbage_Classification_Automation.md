# 2022-1_DTA_Garbage_Classification

​	

# Garbage Classification Automation

2022.06.17. Fri

​	

Handong Global University, School of Mechanical and Control Engineering, 2022-1 DigitalTwin&Automation

21500018 | 강희윤

21700791 | 홍세현

21900726 | 지현빈

​	

​	

## Environment

### Download
재활용품 분류 및 로봇 자동화를 실시간으로 구현한 프로그램은 Anaconda의 가상환경과 Visual Code를 활용하여 구동시킨다. 프로그램 구동을 위한 파일은 아래의 이미지와 같이 python 파일 2개와 3개의 폴더가 필요하다. 

Download link: [Garbage_Classification_Automation](https://github.com/Hongsehyun/2022_1_DigitalTwin_Automation/tree/main/Project%20%232/3.%20Garbage_Classification_Automation), [Pre-Trained_Data_and_Model](https://github.com/Hongsehyun/2022_1_DigitalTwin_Automation/blob/main/Project%20%232/Pre-trained%20Data%20and%20Model.zip)

Pre-Trained_Data_and_Model.zip은 압축을 풀면 아래 이미지의 data 폴더와 같다. 

![image](https://user-images.githubusercontent.com/91526930/174454647-1e83ab7d-b105-424c-9f76-90a0ba0de831.png)

### Anaconda Virtual Environment

* Anaconda Installation Guide: [here](https://ykkim.gitbook.io/dlip/installation-guide/anaconda)

* Anaconda 설치를 완료하면, Anaconda Prompt를 관리자 권한으로 실행한다. 그리고, Anaconda를 업데이트한다. 
<pre><code>conda update -n base -c defaults conda</code></pre>

* python version 3.9의 가상환경을 생성한다.
<pre><code>conda create -n py39_dta python=3.9</code></pre>

* activate를 통해 생성된 가상환경으로 들어간다. 
<pre><code>conda activate py39_dta</code></pre>

* 가상환경 내부에 다음 패키지들을 설치한다. 이 패키지들은 프로그램 구동을 위해 사용되는 것들이다. 
<pre><code>pip install numpy
pip install opencv-python
pip install fastai==1.0.61
pip install tensorflow</code></pre>

​	

​

## Real-Time Image Processing
![image](https://user-images.githubusercontent.com/91526930/174454402-ae332e39-60d6-4117-a160-e315babf480b.png)


* Tracking and Detect object at designated location
<pre><code># 플로 결과 그리기 + 물체 Tracking하며 중심좌표 출력하기
def drawFlow(img, flow, flag_change_ok, step=10):                                                  # step = 그리드 한 칸 한 칸의 간격 지정
    h, w = img.shape[:2]
    flag = 0
    x_center = 0
    y_center = 0
    
    # 10픽셀 간격의 그리드 인덱스 구하기
    idx_y, idx_x = np.mgrid[step/2 : h : step , step/2 : w : step].astype(np.int) 
    indices = np.stack((idx_x, idx_y), axis=-1).reshape(-1, 2)                    # 각 포인트의 좌표를 모두 생성
    
    
    # 인덱스 순회
    for x, y in indices:
        # 각 그리드 인덱스 위치에 점 그리기
        cv.circle(img, (x, y), 1, (0, 212, 255), 1)                                 # img, center, radius, color, thickness

        # 각 그리드 인덱스에 해당하는 플로 결과 값(이동 거리)
        dx, dy = flow[y, x].astype(np.int)
        
        # Thres Val [1] - 충분히 이동하였는가 :: 노이즈, 먼지 등을 탐지하는 경우를 1차로 방지!
        if dx > 5 or dx < -5 or dy > 5 or dy < -5:           
            x_idx.append(x)                                
            y_idx.append(y)
            
            x_center = sum(x_idx)/len(x_idx)                                    
            y_center = sum(y_idx)/len(y_idx)
            
        # 각 그리드 인덱스 위치에서 이동한 거리만큼 선 그리기
        cv.line(img, (x, y), (x+dx, y+dy), (0, 212, 255), 2, cv.LINE_AA)              # img, center, radius, color, thickness
    
    
    # Thres Val [2] - 물체가 실존하는가 :: 노이즈, 먼지 등을 탐지하는 경우를 2차로 방지!
    
    if len(x_idx)>15 and len(y_idx)>15 and x_center > 400:                                     
        if flag_change_ok == 1:
            # print('x_center: {},   y_center: {}\n'.format(x_center, y_center))
            flag = 1
    
    return flag, x_center, y_center</code></pre>
​	

​

## Robot Automation with INDY-10
![image](https://user-images.githubusercontent.com/91526930/174454410-a46534c9-2139-4589-a42e-f86aa69f241e.png)

​	

​

## Garbage Classification Automation with INDY-10
![image](https://user-images.githubusercontent.com/91526930/174454418-27e3e239-7e89-487f-8817-e7bc9a605eda.png)

​	

​	
